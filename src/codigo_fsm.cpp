#include <Arduino.h>
#include "autogenerated/states.h"

#define ELAPSED() (micros() - s.t0)

// Puente H
#define AIA A0
#define AIB A1  
#define BIA A2  
#define BIB A3

// Infrarrojos
#define PIN_SENSOR_IZQUIERDO    9
#define PIN_SENSOR_CENTRO       10
#define PIN_SENSOR_DERECHO      11
#define PIN_SENSORS_MASK        0b00011100
#define PIN_SENSORS_SHIFT       2

#define READ_SENSORS()  ((PINB & PIN_SENSORS_MASK) >> PIN_SENSORS_SHIFT)

// Casos que no tenemos contemplados, mejor ignorar
#define UNDEFINED   125

#define BOTON_ENCENDIDO 7

constexpr float sensors_to_error[] = {
    UNDEFINED,  // ---
    +2,         // --*
     0,         // -*-
    +1,         // -**
    -2,         // *--
    UNDEFINED,  // *-*
    -1,         // **-
    UNDEFINED   // ***
};

constexpr uint8_t kVelMaxIzq = 180;
constexpr uint8_t kVelMaxDer = 210;
constexpr float kP = 28;
constexpr float kD = 1000;

struct ProgramData {
    // State current_state = State::init;
    unsigned long t0;
    unsigned long dt;
    uint8_t velDer = kVelMaxDer;
    uint8_t velIzq = kVelMaxIzq;
    float error_d = 0;
    float last_error = 0;
    float error = 0;
};
ProgramData s{};


/*STATE(init) {
    if (digitalRead(BOTON_ENCENDIDO)) {
        s.current_state = State::follow_line;
    }
} */

/*STATE(follow_line) {
    int16_t error = sensors_to_error[READ_SENSORS()];
    
    // Better safe than sorry
    if (error == UNDEFINED) {
        return;
    }

    float kd = (error - s.last_error) / s.dt;
}*/

void d_controller(){
    s.error_d = (s.error - s.last_error) / (float) s.dt;
    s.last_error = s.error_d;
}

void p_controller() {
    float tmp = sensors_to_error[READ_SENSORS()];
    if (tmp == UNDEFINED) {
        return;
    }

    s.error = tmp;
}

void setup() {
    // Puente H
    pinMode(AIA, OUTPUT);
    pinMode(AIB, OUTPUT);
    pinMode(BIA, OUTPUT);
    pinMode(BIB, OUTPUT);

    pinMode(PIN_SENSOR_IZQUIERDO, INPUT);
    pinMode(PIN_SENSOR_CENTRO, INPUT);
    pinMode(PIN_SENSOR_DERECHO, INPUT);
    Serial.begin(9600);

    pinMode(BOTON_ENCENDIDO, INPUT);
    s.t0 = millis();
}
 
void loop() {
/*
    p_controller();
 
    if ((s.dt = millis() - s.t0) >= 15) {
        s.t0 = millis();
        Serial.println(s.dt);
        d_controller();
        
    }

    s.velDer = min(kVelMaxDer + s.error * kP + kD * s.error_d, 255);
    s.velIzq = min(kVelMaxIzq - s.error * kP - kD * s.error_d, 255);*/
    
    analogWrite(AIA, 0);
    analogWrite(AIB, kVelMaxDer);
    analogWrite(BIA, 0);
    analogWrite(BIB, kVelMaxIzq);

}